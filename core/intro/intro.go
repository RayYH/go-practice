package intro

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Go 语言早期作者
// 1. Robert Griesemer - 参与开发 Java HotSpot 虚拟机
// 2. Rob Pike - 贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言
// 3. Ken Thompson - Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一

// 为什么要创造一门编程语言
// 1. C/C++ 的发展速度无法跟上计算机发展的脚步，人们需要一门新的系统编程语言 (为什么不是 Rust 呢)
// 2. 软件开发领域需要一门具备更高层次概念的低级语言
// 3. 现有的语言要么执行速度快但是编译速度并不理想 (C++)，要么编译速度较快但执行效率不佳 (.NET、Java)、要么开发难度较低但执行速度一般
//    (PHP)，没有一门语言能同时在这三种特性之间达到平衡

// Go 语言主要特性
// 1. 关键字少、易于学习
// 2. 内置 runtime、GC
// 3. 语言层面支持并发
// 4. 静态类型
// 5. 交叉编译

// Go 环境变量
// go env 可以打印出 Go 所使用的环境变量
// GOROOT - Go 的安装位置
// GOARCH - 目标机器的处理器架构，它的值可以是 386、amd64 或 arm
// GOOS - 目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows
// GOBIN - 表示编译器和链接器的安装位置，默认是 $GOROOT/bin
// GOPATH - 工作目录
//
// GOPATH 的路径下可以包含 Go 语言源码文件 (src)、包文件 (pkg) 和可执行文件的路径 (bin)，如果你使用的是 Go 1.0.3 及以后的版
// 本，你可以将 GOBIN 的值设置为空，此时 Go 将会使用默认值。
//
// Go 编译器支持交叉编译，也就是说你可以在一台机器上构建运行在具有不同操作系统和处理器架构上运行的应用程序。为了区分本地机器和目标机器，
// 你可以使用 GOHOSTOS 和 GOHOSTARCH 设置本地机器的操作系统名称和编译体系结构，这两个变量只有在进行交叉编译的时候才会用到，如果你不
// 进行显示设置，他们的值会和指示出目标机器信息的 GOOS 和 GOARCH 一样。

// GO111MODULE
// 1. Go 一开始的包管理机制并不完善，go get 命令会将三方库 master 分支上的代码下载到 $GOPATH/src 目录下
// 2. GO 在 1.11 版本引入了 Go Modules 包管理 (前身是 vgo)，Go Modules 支持按版本下载依赖包 (项目的 go.mod 文件会记录跟踪依赖的包
//    版本)，下载的包的存放位置不再依赖于 $GOPATH 环境变量
// 为了区分上面两种情况，Go 引入了一个决定安装依赖策略的环境变量 GO111MODULE，在不同的 Go 版本中，GO111MODULE 的默认行为也有所不同。
//
// 1.11/1.12
// GO111MODULE=on (Go Modules 策略) 即使项目存在于 $GOPATH 路径下也强制使用 Go modules (配合 go.mod 文件)
// GO111MODULE=off (GOPATH 策略) 强制将依赖包安装在 $GOPATH 下，即使项目不在 $GOPATH 路径下
// GO111MODULE=auto 项目在 $GOPATH 路径下采用 Go Modules 策略，不在 $GOPATH 路径下采用 GOPATH 策略
//
// 1.13
// Go 在 1.13 版本修改了 GO111MODULE=auto 的行为：存在 go.mod 文件或者不存在 go.mod 文件但是并不在 $GOPATH 路径下时采用 Go
// Modules 策略，在 $GOPATH 路径下并且不存在 go.mod 文件采用 GOPATH 策略。

// Runtime
// 尽管 Go 编译器产生的是本地可执行代码，这些代码仍运行在 Go 的 runtime 当中。这个 runtime 类似 Java 和.NET 语言所用到的虚拟机，它
// 负责管理包括内存分配、垃圾回收、栈处理、goroutine、channel、slice、map 和 reflection 等操作。Go 的可执行文件都比相对应的源代码
// 文件要大很多，这恰恰说明了 Go 的 runtime 嵌入到了每一个可执行文件当中。

// GO GC
// Go 拥有简单却高效的标记 - 清除回收器。它的主要思想来源于 IBM 的可复用垃圾回收器，旨在打造一个高效、低延迟的并发回收器。使用一门具有
// 垃圾回收功能的编程语言不代表你可以避免内存分配所带来的问题，分配和回收内容都是消耗 CPU 资源的一种行为。

// Go 标识符
// 1. Go 源文件的名称遵循 snake_case 风格，以 .go 为扩展名，Go 对源文件的大小没有限制
// 2. Go 语言区分大小写 (不同于 PHP)，有效的标识符必须以字母 (可以使用 _ 或任何 UTF-8 编码的字符) 开头，然后紧跟着 0 个或多个字符
// 3. _ 是空白标识符，任何赋给这个标识符的值都将被抛弃
// 4. Go 有 25 个关键字和用于基本类型或内置函数的 36 个预定义标识符

// Go 包
// 1. 包是结构化代码的一种方式 (类似于其他编程语言中的类库或者命名空间)，你必须在源文件中非注释的第一行指明这个文件属于哪个包
// 2. 属于同一个包的源文件必须全部被一起编译，包是编译时的一个单元，因此根据惯例，每个目录都只包含一个包
// 3. 如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译

// Go 可见性规则
// 1. 当标识符以一个大写字母开头，那么使用这种形式的标识符的对象就可以被外部包的代码所使用，这被称为导出
// 2. 标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的

// Go 注释
// 1. // 表示单行注释
// 2. /* */ 表示多行注释
// 3. 在 package 语句之前的块注释将被默认认为是这个包的文档说明，其中应该提供一些相关信息并对整体功能做简要的介绍

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
